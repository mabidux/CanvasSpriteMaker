<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Maker</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito&display=swap');
        * {
            margin: 0;
        }
        .nunito {
            font-family: 'Nunito', sans-serif;
        }
    </style>
</head>
<body>
    <div style="text-align: center; margin-top: 2%; margin-bottom: 2%;">
        <h1 class="nunito">Sprite Maker</h1>
        <br>
        <input type="color" id="color" style="border-radius: 5px; outline: none;">
    </div>
    <div style="width: 600px; height: 600px; margin: auto; margin-bottom: 2%;">
        <canvas width="600px" height="600px" style="border: .1rem solid black; image-rendering: crisp-edges; image-rendering: -moz-crisp-edges; image-rendering: pixelated;"></canvas>
    </div>
    <div style="text-align: center; margin-bottom: 2%;" class="nunito">
        <input type="text" id="code" value="" style="visibility: visible; outline: none;" readonly>
        <button onclick="copiar()">Salvar</button>
    </div>
    <script>
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('2d');
        const color = document.querySelector('#color');
        
        color.oninput = () => document.querySelector('h1').style.color = color.value;

        const gridList = [];
        let paintedGrids = [];
        let previousGrids = [];

        const gridPixels = 10;

        for (let y = 1; y <= canvas.height / gridPixels; y++) {
            for (let x = 1; x <= canvas.width / gridPixels; x++) {
                let leftX = (x - 1) * gridPixels;
                let rightX = x * gridPixels;
                let upY = (y - 1) * gridPixels;
                let downY = y * gridPixels;
                gridList.push({'leftX': leftX, 'rightX': rightX, 'upY': upY, 'downY': downY});
            }
        }

        let pressing = false;
        let button = 0;
        document.addEventListener('mousedown', event => {
            pressing = true
            button = event.button;
        });
        document.addEventListener('mouseup', event => {
            pressing = false;
            button = 0;
        });

        let currentGrid = null;
        
        function render() {
            context.clearRect(0, 0, 600, 600);
            for (paintedGrid of paintedGrids) {
                context.fillStyle = paintedGrid.color;
                context.fillRect(paintedGrid.grid.leftX, paintedGrid.grid.upY, gridPixels, gridPixels);
            }

            for (paintedGrid of previousGrids) {
                context.fillStyle = paintedGrid.color;
                context.fillRect(paintedGrid.grid.leftX, paintedGrid.grid.upY, gridPixels, gridPixels);
            }
        }

        canvas.onmousemove = event => {
            render();
            let mousePosition = getMousePosition(event);
            for (grid of gridList) {
                if (mousePosition.x >= grid.leftX && mousePosition.x <= grid.rightX && mousePosition.y <= grid.downY && mousePosition.y >= grid.upY) {
                    context.fillStyle = "#7070708c";
                    context.fillRect(grid.leftX, grid.upY, gridPixels, gridPixels);
                    currentGrid = grid;
                    break;
                }
            }
            if (pressing && button === 0) paint();
            if (pressing && button === 2) erase();
        }

        function hasGrid(grid) {
            for (g of paintedGrids) if (grid === g.grid) return true;
            return false;
        }

        canvas.onclick = () => paint();

        canvas.addEventListener('contextmenu', event => {
            event.preventDefault();
            erase();
        });

        function paint() {
            if (currentGrid !== null && !hasGrid(currentGrid)) {
                let colorValue = color.value;
                context.fillStyle = colorValue;
                context.fillRect(currentGrid.leftX, currentGrid.upY, gridPixels, gridPixels);
                paintedGrids.push({'grid': currentGrid, 'color': colorValue});
            }
        }

        function erase() {
            if (currentGrid !== null) {
                for (grid of paintedGrids) {
                    if (grid.grid === currentGrid) {
                        paintedGrids.splice(paintedGrids.indexOf(grid), 1);
                        context.fillStyle = "#fff";
                        context.fillRect(grid.grid.leftX, grid.grid.upY, gridPixels, gridPixels);
                        break;
                    }
                }
            }
        }

        function getMousePosition(event) {
            let width = document.body.clientWidth;
            let x = event.pageX - width / 2 + canvas.width / 2;
            let y = event.pageY - canvas.offsetTop;
            return {'x': x, 'y': y};
        }

        function copiar() {
            let code = document.getElementById('code');
            salvar(code);
            code.select();
            code.setSelectionRange(0, 99999);
            document.execCommand("copy");
            alert('Copiado.');
        }

        function salvar(code) {
            let minX = 601;
            let minY = 601;
            for (coloredGrid of paintedGrids) {
                if (coloredGrid.grid.leftX < minX) minX = coloredGrid.grid.leftX;
                if (coloredGrid.grid.upY < minY) minY = coloredGrid.grid.upY;
            }

            let pg = paintedGrids;

            for (coloredGrid of pg) {
                coloredGrid.grid.leftX -=  minX;
                coloredGrid.grid.rightX -= minX;
                coloredGrid.grid.upY -= minY;
                coloredGrid.grid.downY -= minY;
            }

            let cd = '{"grids":[';

            for (coloredGrid of pg) {
                cd += `{"color": "${coloredGrid.color}", "grid": [${coloredGrid.grid.leftX}, ${coloredGrid.grid.upY}]},`;
            }

            cd = cd.substring(0, cd.length - 1) + ']}';

            code.value = cd;

            previousGrids = paintedGrids.splice(0, paintedGrids.length);

            for (coloredGrid of previousGrids) {
                coloredGrid.color = `${coloredGrid.color}8c`;
                coloredGrid.grid.leftX += minX;
                coloredGrid.grid.rightX += minX;
                coloredGrid.grid.upY += minY;
                coloredGrid.grid.downY += minY;
            }

            render();
        }

    </script>
</body>
</html>